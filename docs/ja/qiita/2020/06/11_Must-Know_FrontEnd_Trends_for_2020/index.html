<!DOCTYPE html><html lang="ja"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>qiita/2020/06/11_Must-Know_FrontEnd_Trends_for_2020 · baby-degu</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="# 2020年の11の必見のフロントエンドトレンド"/><meta name="docsearch:language" content="ja"/><meta property="og:title" content="qiita/2020/06/11_Must-Know_FrontEnd_Trends_for_2020 · baby-degu"/><meta property="og:type" content="website"/><meta property="og:url" content="https://baby-degu.github.io/"/><meta property="og:description" content="# 2020年の11の必見のフロントエンドトレンド"/><meta property="og:image" content="https://baby-degu.github.io/img/baby-degu.jpg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://baby-degu.github.io/img/baby-degu.jpg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://baby-degu.github.io/blog/atom.xml" title="baby-degu Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://baby-degu.github.io/blog/feed.xml" title="baby-degu Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ja"><h2 class="headerTitle">baby-degu</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/ja/" target="_self">Projects</a></li><li class=""><a href="https://github.com/baby-degu/portal" target="_blank">Github</a></li><li class=""><a href="/blog/" target="_self">ブログ</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>日本語</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/qiita/2020/06/11_Must-Know_FrontEnd_Trends_for_2020">English</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">qiita/2020/06/11_Must-Know_FrontEnd_Trends_for_2020</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="2020年の11の必見のフロントエンドトレンド"></a><a href="#2020年の11の必見のフロントエンドトレンド" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2020年の11の必見のフロントエンドトレンド</h1>
<p>ランチ中のフロントエンドトークでスマートに見られる方法！</p>
<p><img src="https://miro.medium.com/max/2400/1*4o8a1yvlifG4zGw9AvSSrQ.png" alt=""></p>
<p>チームのランチトークでスマートに見られることは、最新のフロントエンドのトレンドを常に把握しておくための大きな理由であることは言うまでもない。 それは、あなたがより良い開発者になり、より良い技術とより良い製品を作るのに役にたつかもしれない。 たぶんね。</p>
<p>だから、いくつかの興味深い方向を示すことで、この名誉あるクエストを君が簡単に達成できるように少し時間をもらいたい。 すべてのコンセプトについて1から10まで説明するのではなく、そのコンセプトとそれがどのように有用であるか紹介しよう。最後にはさらなるリソースを書き記した。</p>
<p>例えば、マイクロフロントエンド、アトミックデザイン、Webコンポーネント、TypeScriptの台頭、ESM CDN、さらにはデザイントークンの概要についても簡単に説明している。 スクロールして、詳細を知りたいトピックをチェックしてみてほしい。 質問や提案がある場合は、下部にコメントを残してもらえればと思う。 それではごゆっくり！</p>
<hr>
<h2><a class="anchor" aria-hidden="true" id="1-マイクロフロントエンド"></a><a href="#1-マイクロフロントエンド" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. マイクロフロントエンド</h2>
<p>マイクロフロントエンドは、ランチの会話で最も話題になるフロントエンドトピックだ。</p>
<p>皮肉なことに、フロントエンド開発はコンポーネントのモジュール化された利点を享受しているが、それでもバックエンドマイクロサービスよりもはるかにモノリシックだ。</p>
<p><a href="https://micro-frontends.org/"><img src="https://miro.medium.com/max/1180/1*SdrrxeKfuAyDEAKATFNUNg.png" alt=""></a></p>
<p>マイクロフロントエンドは、アプリの異なる部分で作業する異なるチームのために、フロントエンドアーキテクチャを異なるフロントエンドに分割するという約束をもたらしてくれる。 各チームは、マイクロフロントエンドのエンドツーエンドのライフサイクル全体で自律性を獲得できる。これらは（例えば** Bit**などのツール</a>を使用することで）開発、バージョン管理、テスト、ビルド、レンダリング、アップデート、デプロイが独立して可能だ。</p>
<p>ここでコンセプト全体を説明する代わりに、@martcamwlerのブログで公開された@thecamjacksonによる<a href="https://martinfowler.com/articles/micro-frontends.html#InANutshell"><strong>この素晴らしい投稿を読んでみてほしい</strong></a> 。 この記事は本当にすばらしく、この概念を掘り下げるために必要なすべてをカバーしているはずだ。</p>
<p><a href="https://martinfowler.com/articles/micro-frontends.html"><img src="https://miro.medium.com/max/1702/1*fxACkCp1y_fDwnF-N7bVMQ.png" alt=""></a></p>
<p>しかしながら、今日のエコシステムにはそれでもまだ足りないものがある。 多くの場合、分離されたフロントエンドの展開、バンドル、環境の違いなどの問題に悩まされる。しかし、<a href="https://bit.dev"><strong>Bit</strong></a>を使うことで個々のフロントエンド/コンポーネントの分離、バージョン管理、ビルド、テスト、アップデートができるようになる。 現時点では、これは主に複数のアプリケーションを操作するときに役立つ（コンポーネントを介して既存のアプリの一部を徐々にリファクタリングするためにすでに広く使用されているが）。</p>
<p><strong>Bit</strong>が2020年にデプロイメントを開始すれば、独立したチームがスタンドアロンのフロントエンドを開発、構成、バージョン管理、デプロイ、アップデートできるようになる。 これにより、UIアプリを一緒に構成し、チームが独立した継続的なデプロイと増分アップグレードを使用して、シンプルな分離されたコードベースを作成できるようになる。 これらのフロントエンドを組み合わせることにより、最終的にアプリケーションができあがる。 Bitを使用して構成されたアプリは次のようになる。</p>
<p><a href="https://bit.dev"><img src="https://miro.medium.com/max/2400/1*pHH9k186BYju30BC9OxXTg.png" alt=""></a></p>
<p>Bitで構成されたUIアプリ</p>
<h3><a class="anchor" aria-hidden="true" id="もっと詳しく"></a><a href="#もっと詳しく" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>もっと詳しく:</h3>
<blockquote>
<p><a href="https://martinfowler.com/articles/micro-frontends.html">マイクロフロントエンド</a></p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="2-アトミックデザイン"></a><a href="#2-アトミックデザイン" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. アトミックデザイン</h2>
<p><a href="https://blog.bitsrc.io/atomic-design-and-ui-components-theory-to-practice-f200db337c24?"><img src="https://miro.medium.com/max/6528/1*q5IW7xZF8AYFj8NZEVi17Q.jpeg" alt=""></a></p>
<p>参考：アトミックデザインを30秒で理解する！</p>
<p><a href="https://bradfrost.com/blog/post/atomic-web-design/">アトミックデザイン</a>はランチトークのもう1つの非常に興味深いトピックで、私はこれを純粋な方法論というよりも原理として考えるようにしている。</p>
<p>簡単に言えば、<a href="https://medium.com/u/52f676b44c62?source=post_page-----cea8a629b08----------------------">Brad Frost</a> によって導入されたこの理論は、Webアプリケーションの構成 － 突き詰めると具体的なWebページと、原子（Atom）・分子（Molecule）・有機体（Organism）といった自然界の構成とを比較するものだ。 原子は分子を構成する。（例：テキスト入力「原子」 + ボタン「原子」 + ラベル「原子」=検索「分子」）。 分子は有機体を構成する。 有機体は１つのレイアウトテンプレートに存在しており、これはユーザーに配信される１つのWebページとして具現化される。</p>
<p>これは<a href="/atomic-design-and-ui-components-theory-to-practice-f200db337c24">_ 視覚的な例を用いた30秒でわかる説明_</a>だ。そこには、私が素晴らしい芸術的才能で描いたとても印象的な説明図があるから、どうぞオフィスのホワイトボードに書き写して使ってほしい😆</p>
<p>アトミックコンポーネントの利点は、モジュール式の再利用可能なコンポーネントを介したモジュール式のUIアプリケーションを構築できるというだけではない。 このパラダイムに従うと、すべてのコンポーネントの役割とAPI、それらの階層、アプリケーションのビルドプロセスを効果的かつ効率的な方法で抽象化できる方法についてよりよく理解できるように構成を考える必要が出てくる。 次の記事を読んでほしい。</p>
<h3></h3>
<blockquote>
<p><a href="https://bradfrost.com/blog/post/atomic-web-design/">アトミックデザイン</a></p>
</blockquote>
<blockquote>
<p><a href="/atomic-design-and-ui-components-theory-to-practice-f200db337c24">アトミックデザイン：実践のための理論</a></p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="3-カプセル化されたスタイリングとshadow-dom"></a><a href="#3-カプセル化されたスタイリングとshadow-dom" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3. カプセル化されたスタイリングとShadow DOM</h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM"><img src="https://miro.medium.com/max/2276/1*TSOpITlAqbyYC_UYYW7zMg.png" alt=""></a></p>
<p>出典：developer.mozzila.org</p>
<p>コンポーネントの重要な側面はカプセル化だ。これにより、マークアップ構造、スタイル、および動作をページ上の他のコードから分離して、異なる部分が衝突しないようにできる。また、コードをきれいに保つことができる。 <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM"> Shadow DOM API </a>はこれの重要な部分であり、非表示の分離されたDOMを要素にアタッチする方法を提供してくれる。</p>
<p>今日、<em>Shadow</em> DOMは実際にブラウザーで長い間使用されている。 <a href="https://bitsofco.de/what-is-the-shadow-dom/">Shadow DOMを次のように考えることができる。</a> 「DOMの中にあるDOM」 これは、元のDOMから完全に分離された、独自の要素とスタイルを持つ独自の分離DOMツリーだ。</p>
<p>これにより、非表示のDOMツリーが通常のDOMツリーの要素に接続することができるようになる。このShadow DOMツリーは、通常のDOMと同じ方法で、あなたが必要とする要素に接続できるシャドウルートから始まる。 これが<a href="https://dev.to/maxart2501/css-for-an-encapsulated-web-7fo">主に意味すること</a>は、クラスに与える<em>名前空間が必要ない</em>ということだ。 つまり名前の衝突やスタイルの流出のリスクがないということだ。 また、他にも利点がある。 これはWebコンポーネントのスタイルの真のカプセル化に対する当分約束されたソリューションであるとしばしば言われている。 もっと詳しく:</p>
<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM">shadow DOMを使う</a></p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="4-typescriptの台頭"></a><a href="#4-typescriptの台頭" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4. TypeScriptの台頭</h2>
<p>最近、どんな会話でも<a href="https://medium.com/@jtomaszewski/why-typescript-is-the-best-way-to-write-front-end-in-2019-feb855f9b164">TypeScriptがフロントエンド開発を支配する</a>かのように言われている。 <a href="https://2018.stateofjs.com/javascript-flavors/typescript/">** 80％の開発者が次のプロジェクトでTypeScriptを使用または学習したいと認めている**</a>という報告がある 。</p>
<p>TypeScriptには欠点もあるが、コードは理解しやすく、実装が高速で、バグが少なく、必要なボイラープレートが少なくて済む。 TSで動作するようにReactアプリをリファクタリングしてみたい？ やってみよう。 徐々に始めたい？ <a href="https://github.com/teambit/bit">Bit</a>などのツールを使って、アプリのコンポーネントを徐々にTSにリファクタリングしてみよう。そしてそれらを<a href="https://bit.dev/bit/envs/compilers/react-typescript"> React-Typescriptコンパイラ</a>を使用してアプリとは独立にビルドしよう。 この方法では、コードを1コンポーネントずつ徐々にアップグレードできる。</p>
<h3><a class="anchor" aria-hidden="true" id="もっと詳しく-1"></a><a href="#もっと詳しく-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>もっと詳しく:</h3>
<blockquote>
<p><a href="https://medium.com/@jtomaszewski/why-typescript-is-the-best-way-to-write-front-end-in-2019-feb855f9b164">TypeScriptが2019年にフロントエンドを作成する最良の方法である理由</a></p>
</blockquote>
<blockquote>
<p><a href="https://eng.lyft.com/typescript-at-lyft-64f0702346ea">LyftでのTypeScript</a></p>
</blockquote>
<blockquote>
<p><a href="https://slack.engineering/typescript-at-slack-a81307fa288d">SlackでのTypeScript</a></p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="5-webコンポーネント"></a><a href="#5-webコンポーネント" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5. Webコンポーネント</h2>
<p><img src="https://miro.medium.com/max/3200/1*-zkpV1IfOv-1dux6ZqWBCQ.png" alt=""></p>
<p>基本的に、これは未来だ。 なぜかって？ これらの純粋なWebコンポーネントはフレームワークにとらわれず、フレームワークなしでも、どんなフレームワークの<strong>標準的な構文</strong>でも機能するからだ 。 JS疲労から解放され、最新のブラウザでサポートされているからだ。 バンドルサイズと消費量が最適化されていて、VDOMレンダリングは驚くほど素晴らしいからだ。</p>
<p>これらのコンポーネントは、新しい種類のhtmlタグを定義できるJavascript API、レイアウトを指定するHTMLテンプレート、そしてもちろんコンポーネント固有のShadow DOMを提供するカスタム要素を提供する。</p>
<p>この分野でよく知られているツールは、<a href="https://github.com/Polymer/lit-html">** Lit-html **</a>（<a href="https://lit-element.polymer-project.org/"> Lit-element</a>も）だ。<a href="https://github.com/ionic-team/stencil">** StencilJS **</a> 、<a href="https://github.com/sveltejs/svelte">** SvelteJS **</a>そしてもちろん<a href="https://bit.dev/"><strong>Bit</strong></a>だ。どこでも直接共有できて、使うことができて、開発もできる再利用可能なモジュール式コンポーネントを提供してくれる。</p>
<p>私たちのUI開発の将来と、モジュール化、再利用性、カプセル化、および標準化の原則がコンポーネントの時代にどのように見えるかを考えるとき、Webコンポーネントががその答えだ。 もっと詳しく:</p>
<ul>
<li><a href="/7-tools-for-developing-web-components-in-2019-1d5b7360654d">2019年にWebコンポーネントを開発するための7つのツール</a></li>
<li><a href="/9-web-component-ui-libraries-you-should-know-in-2019-9d4476c3f103">2019年に知っておくべき9つのWebコンポーネントUIライブラリ</a></li>
<li><a href="/prototyping-with-web-components-build-an-rss-reader-5bb753508d48">Webコンポーネントを使用したプロトタイピング：RSSリーダーを作る</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="6-コンポーネントライブラリから動的コレクションへ"></a><a href="#6-コンポーネントライブラリから動的コレクションへ" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>6. コンポーネントライブラリから動的コレクションへ</h2>
<p><a href="https://bit.dev"><img src="https://miro.medium.com/max/1838/1*VmerRS_ufSltgSGYiNHinQ.png" alt=""></a></p>
<p>コンポーネントを動的コレクションとして編成しよう。再利用し、構成し、独立性を保つのだ。</p>
<p><a href="/a-guide-to-component-driven-development-cdd-69dbd3d07bf0?source=collection_home---4------13-----------------------">コンポーネント駆動開発</a>の登場はさまざまなツールを生み出した。 有名なツールの1つはホスティングプラットフォームの<a href="https://bit.dev"> Bit.dev</a>ならびに<a href="https://github.com/teambit/bit">Bit</a>だ 。</p>
<p>厄介で高度に結合されたコンポーネントライブラリを構築するために一生懸命働く代わりに、ビットを使用して、既存のコンポーネント同士の分離、動的に再利用可能な共有コレクションへのエクスポートを継続的に行おう。</p>
<p><a href="https://github.com/teambit/bit">Bit（GitHub） </a>を使うことによって、 UIコンポーネントの分離、バージョン管理、ビルド、テスト、更新を独立して行うことが可能だ。 Bitを使えば既存のアプリにあるコンポーネントの単離、リモートコレクションへの保存、場所を問わない使用のプロセスを合理化できる。 すべてのコンポーネントは、プロジェクトの外部でのビルド、テスト、レンダリングが可能だ。 また、アプリ全体ではなく、単一のコンポーネント（およびその依存コンポーネント）を更新することができる。</p>
<p><a href="https://bit.dev"><img src="https://miro.medium.com/max/1600/1*c6475ieLqqEzb4htt3T94Q.gif" alt=""></a></p>
<p>Bit.devプラットフォーム（または独自のサーバー）では、コンポーネントをリモートでホストし、異なるチーム向けに編成できるため、それを使ってすべてのチームが独自のコンポーネントの開発を行うことができる。 すべてのチームはコンポーネントを共有して再利用できるが、コンポーネントの独立性と制御は保つことができるのだ。</p>
<p>このプラットフォームは、すぐに使える共有コンポーネントのオールインワンエコシステムも提供している。UIコンポーネントを自動ドキュメント化し、インタラクティブなプレイグラウンドでコンポーネントをレンダリングし、npm/yarnを使用してコンポーネントをインストールするための組み込みレジストリを提供してさえくれる。 さらに、どんなリポジトリでも変更のために<code>`bit import`</code>でコンポートネントをインポートできる。</p>
<p><a href="https://bit.dev"><img src="https://miro.medium.com/max/1600/1*RZP_jNEEilVtmjGH4O4UHQ.gif" alt=""></a></p>
<p>短期的に見ると、これは以前のCDミュージックアルバムを介した音楽の共有プロセスをSpotify / iTunesが変えたのと同じように、コンポーネントを共有および作成するプロセスに革命をもたらしている。 これは、誰もがコンポーネントを共有して一緒に使用できるようにする動的かつモジュール式のソリューションだ。</p>
<p>長期的に見れば、Bitはマイクロフロントエンドへの道を開拓するのに役立つ。 なぜかって？ それはUIアプリケーションの一部分のバージョン管理、テスト、ビルド、更新を独立して実行することができるようになっているからだ。 2020年にBitには独立したデプロイメント機能が導入され、最終的にはさまざまなチームがアプリの一部をエンドツーエンドで所有できるようになる。分離されたシンプルなコードベースを維持し、チームが慎重かつ継続的に段階的にUIの更新をビルド・デプロイし、フロントエンドを構成することができるようになるということだ。</p>
<h3></h3>
<blockquote>
<p><a href="https://bit.dev">再利用可能なコードコンポーネントをチームとして共有する・Bit</a></p>
</blockquote>
<blockquote>
<p><a href="https://bit.dev/collections">UIコンポーネント設計システム・Bit</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/teambit/bit">teambit / bit</a></p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="7-状態管理ばいばい-redux-いや"></a><a href="#7-状態管理ばいばい-redux-いや" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7. 状態管理：ばいばい Redux？ （いや...）</h2>
<p><img src="https://miro.medium.com/max/2290/1*6oeKSYnPG2pbg8vdaiteYg.png" alt=""></p>
<p><a href="/state-of-react-state-management-in-2019-779647206bbc"> Reduxは倒すのが難しいビーストだ</a> 。 フロントエンドがモジュール化されるにつれて、アプリの状態をグローバルに管理することの苦痛はより明確になるが、Reduxの有用性の高さは多くのチームにとって頼りになるソリューションだ。</p>
<p>では、2020年にReduxに別れを告げることになるのだろうか。 おそらく完全にそうなることはないだろう😄</p>
<p>ただし、状態を処理するフレームワーク内の新機能（React hooks、Context-APIなど）の誕生は、グローバルストアのない未来への道を描いている。 <a href="https://github.com/mobxjs/mobx"> Mobx</a>のようなツール群は1年前に採用されたばかりだが、それらコンポーネント指向でスケーラブルな性質のおかげで、ますます人気が高まってきている。 <a href="/state-of-react-state-management-in-2019-779647206bbc">ここでより多くの選択肢</a>を見つけることができる。</p>
<p><em>参考</em>：<a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889"><em>React Hooksを理解する</em></a> — <a href="https://medium.com/u/a3a8af6addc1?source=post_page-----cea8a629b08----------------------"> Dan Abramov</a></p>
<h2><a class="anchor" aria-hidden="true" id="8-esm-cdn"></a><a href="#8-esm-cdn" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>8. ESM CDN</h2>
<p><img src="https://miro.medium.com/max/4000/1*dSWVWelaiGClQXD6nGhBuA.jpeg" alt=""></p>
<p>ESモジュールは、ブラウザでJSのモジュールを操作するための標準規格であり、ECMAScriptによって標準化されている。 ESモジュールを使用すると、CDNなどを介して使用できるモジュールに機能を簡単にカプセル化できる。 Firefox 60のリリースにより、すべての<a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">主要ブラウザが ESモジュールをサポートするようになる</a>。Node mteamはESモジュールサポートを<a href="https://nodejs.org/en/"> Node.js</a> に追加する作業に取り組んでいる。 また、<a href="https://www.youtube.com/watch?v=qR_b5gajwug">WebAssemblyに向けてのESモジュール統合</a>が今後数年間に対応されるだろう。  CDNを介して、モジュール式<a href="https://github.com/teambit/bit">Bit</a>UIコンポーネントをアプリに組み込めることを想像してみよう...</p>
<ul>
<li><a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">ESモジュール：漫画の詳細— Mozilla Hacks — Web開発者ブログ</a></li>
<li><a href="https://github.com/denoland/deno">denoland/deno</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="9-プログレッシブwebアプリケーション-まだまだ成長中"></a><a href="#9-プログレッシブwebアプリケーション-まだまだ成長中" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>9. プログレッシブWebアプリケーション。 まだまだ成長中。</h2>
<p><a href="https://developers.google.com/web/progressive-web-apps">プログレッシブWebアプリケーション</a>は最新のテクノロジーを活用して、<a href="https://www.smashingmagazine.com/2016/08/a-beginners-guide-to-progressive-web-apps/">Webアプリとモバイルアプリのいいとこどり</a>をしたものだ 。 これは、ウェブテクノロジーを使用して構築されたウェブサイトであるが、モバイルアプリのようなふるまい、UXをもつものであると考えればよい。 Service Worker、Cache API、Push APIの可用性向上とブラウザの近年の進歩により、Web開発者はモバイルユーザーのホーム画面にWebアプリをインストールし、プッシュ通知を受信させ、さらにはオフラインで機能させることさえ可能になった。</p>
<p>PWAは快適なユーザーエクスペリエンスを提供できるようにしているためか、すべてのネットワークリクエストはサービスワーカーを介して傍受される可能性があるため、アプリをHTTPS経由でホストして中間者攻撃を防止し、セキュリティを強化することが不可欠だ。 <a href="https://medium.com/u/49b16006351c?source=post_page-----cea8a629b08----------------------">ここでFacebookの開発者Omer Goldberg</a>によるPWAのベストプラクティスの概要の解説を読むことができる。</p>
<h2><a class="anchor" aria-hidden="true" id="10-デザイナーと開発者の統合"></a><a href="#10-デザイナーと開発者の統合" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>10. デザイナーと開発者の統合</h2>
<p><a href="https://bit.dev"><img src="https://miro.medium.com/max/1600/1*55RGwH_5D3mIZoVhSCXWOA.gif" alt=""></a></p>
<p><a href="/building-a-consistent-ui-design-system-4481fb37470f">プロダクトやチーム全体で一貫したU</a>Iを実現する<a href="https://dev.to/jonisar/ui-component-design-system-a-developer-s-guide-19fg">コンポーネント駆動設計システム</a>の誕生とともに 、デザイナーと開発者の間のギャップを埋めるための<a href="/7-tools-for-building-your-design-system-in-2020-452d9c9b3b8e">新しいツールが登場した</a>。 <a href="https://codeburst.io/ui-design-system-and-component-library-where-things-break-d9c55dc6e386">とはいえこれは簡単な作業ではない</a>。実際にはコード自体が唯一の真の情報源だが（コードこそがユーザーに実際にいきわたるものだ）、ほとんどのツールはデザイナー側からのギャップを埋めようとしている。 このカテゴリには、Framer、Figma、Invision DSMなどがある。</p>
<p>開発者側からの視点では、<a href="https://bit.dev"> Bit.dev</a>のようなプラットフォームが 、次世代のコンポーネントライブラリをホストし、共有コンポーネントの採用を支援している。 このプラットフォームは、実際のソースコードのレンダリングして視覚化してくれるため、デザイナーは開発者と共同で作業し、ソースコード自体について視覚的な方法でディスカッションできるようになる。</p>
<p>注意すべきもう1つの有望なアイデアは、<a href="https://css-tricks.com/what-are-design-tokens/"> design-tokens </a>だ 。 トークンをコードに配置することにより、デザイナーは外部のコラボレーションツールを介して単純なスタイリングの側面（色など）を直接制御できる。 これはBit.devのようなプラットフォームと統合されており、これまでよりも厳しいワークフローを作成できる。</p>
<blockquote>
<p><a href="https://dev.to/jonisar/ui-component-design-system-a-developer-s-guide-19fg">UIコンポーネント設計システム：開発者ガイド</a></p>
</blockquote>
<blockquote>
<p><a href="https://codeburst.io/ui-design-system-and-component-library-where-things-break-d9c55dc6e386">UIデザインシステムとコンポーネントライブラリ：物事が壊れるところ</a></p>
</blockquote>
<blockquote>
<p><a href="/7-tools-for-building-your-design-system-in-2020-452d9c9b3b8e">2020年にデザインシステムを構築するための7つのツール</a></p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="11-webアセンブリ--未来へ"></a><a href="#11-webアセンブリ--未来へ" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>11. Webアセンブリ — 未来へ？</h2>
<p><a href="https://webassembly.org/"> Webアセンブリ（Wasm）</a> はWeb開発に言語多様性をもたらし、JavaScriptによってもたらされた隔たりを埋めてくれる。 Wasmは、「スタックベースの仮想マシン用のバイナリ命令フォーマット」として定義されている。 Wasmは、C / C ++ / Rustのような高水準言語のコンパイル用のポータブルターゲットとして設計されており、クライアントアプリケーションおよびサーバーアプリケーションのWebへの展開を可能にしてくれる。</p>
<p><a href="https://medium.com/u/c359511de780?source=post_page-----cea8a629b08----------------------"> Eric Elliott </a>は彼の投稿でそのコンセプトの利点を次のようにエレガントに概説している。</p></p>
<ul>
<li>** JavaScriptの改善： ** wasmでパフォーマンスが重要なものを実装し、標準のJavaScriptモジュールのようにインポートできる。</li>
<li><strong>新しい言語： ** WebAssemblyコードは、</strong>バイナリ形式**で表されるAST（抽象構文ツリー）を定義できる。 <strong>テキスト形式で書いてデバッグ可能だ</strong>。つまり可読性が高い。</li>
<li><strong>ブラウザの改善： ** <strong>ブラウザはバイナリ形式を理解できる</strong>。これは、現在使用しているテキスト形式のJavaScriptコードよりもより高くい圧縮率をもつバイナリバンドルをコンパイルできることを意味する。 ペイロードが小さいほど、配信が速くなる。 また、</strong>コンパイル時の最適化のケース**によっては、WebAssemblyバンドルもJavaScriptよりも高速に実行されるかもしれない！</li>
<li>**コンパイルターゲット： **他の言語がWebプラットフォームスタック全体でファーストクラスのバイナリサポートを取得する方法である。</li>
</ul>
<p>なぜそれが有用で、どこで使用されるようになるのか、そしてなぜまだ目にしないのか、このコンセプトについてさらに理解するためには、<a href="https://medium.com/javascript-scene/why-we-need-webassembly-an-interview-with-brendan-eich-7fb2a60b0723">この素晴らしい投稿</a>と<a href="https://www.youtube.com/watch?v=aZqhRICne_M&amp;feature=emb_title">この素晴らしいビデオ</a>を見ることをおすすめする 。</p>
<blockquote>
<p><a href="https://medium.com/javascript-scene/why-we-need-webassembly-an-interview-with-brendan-eich-7fb2a60b0723">WebAssemblyが必要な理由：Brendan Eichへのインタビュー</a></p>
</blockquote>
<hr>
<h2><a class="anchor" aria-hidden="true" id="もっと詳しく-2"></a><a href="#もっと詳しく-2" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>もっと詳しく</h2>
<blockquote>
<p><a href="/maximizing-code-reuse-in-react-35ee20ad362c">Reactでのコード再利用を最大化する</a></p>
</blockquote>
<blockquote>
<p><a href="/13-top-react-component-libraries-for-2020-488cc810ca49">2020年のトップ13のReactコンポーネントライブラリ</a></p>
</blockquote>
<blockquote>
<p><a href="/11-top-angular-developer-tools-for-2020-3d2621f1e157">2020年のトップ11のAngular開発者ツール</a></p>
</blockquote>
<blockquote>
<p><a href="/top-10-vuejs-developer-tools-becd61375447">2020年のトップ11のVue開発者ツール</a></p>
</blockquote>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#1-マイクロフロントエンド">1. マイクロフロントエンド</a><ul class="toc-headings"><li><a href="#もっと詳しく">もっと詳しく:</a></li></ul></li><li><a href="#2-アトミックデザイン">2. アトミックデザイン</a></li><li><a href="#3-カプセル化されたスタイリングとshadow-dom">3. カプセル化されたスタイリングとShadow DOM</a></li><li><a href="#4-typescriptの台頭">4. TypeScriptの台頭</a><ul class="toc-headings"><li><a href="#もっと詳しく-1">もっと詳しく:</a></li></ul></li><li><a href="#5-webコンポーネント">5. Webコンポーネント</a></li><li><a href="#6-コンポーネントライブラリから動的コレクションへ">6. コンポーネントライブラリから動的コレクションへ</a></li><li><a href="#7-状態管理ばいばい-redux-いや">7. 状態管理：ばいばい Redux？ （いや...）</a></li><li><a href="#8-esm-cdn">8. ESM CDN</a></li><li><a href="#9-プログレッシブwebアプリケーション-まだまだ成長中">9. プログレッシブWebアプリケーション。 まだまだ成長中。</a></li><li><a href="#10-デザイナーと開発者の統合">10. デザイナーと開発者の統合</a></li><li><a href="#11-webアセンブリ--未来へ">11. Webアセンブリ — 未来へ？</a></li><li><a href="#もっと詳しく-2">もっと詳しく</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"></a><div><h5>Categories</h5><a href="/docs/ja/qiita/index.html">Qiita</a><a href="/docs/ja/udemy/index.html">Udemy</a><a href="/docs/ja/dao/index.html">DAO</a></div><div><h5>Community</h5><a href="https://discord.gg/xCRqdUU" target="_blank" rel="noreferrer noopener">Project Chat</a><a href="https://twitter.com/babydegu" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/baby-degu">GitHub</a><a class="github-button" href="https://github.com/baby-degu/portal" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a><div class="social"><a href="https://twitter.com/babydegu" class="twitter-follow-button">Follow @babydegu</a></div></div></section><section class="copyright"><a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noreferrer noopener">Content is licensed under CC BY-SA 4.0</a></section></footer></div><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script></body></html>